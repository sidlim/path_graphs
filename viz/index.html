<!DOCTYPE html>
<html>

<head>
    <title>Pathology Graphs</title>
    <script src='https://cdn.jsdelivr.net/npm/d3@7'></script>
    <script src='data/1Dgraph.js'></script>
    <script src='umls-query.js'></script>
    <style type='text/css'>
        svg {
            height: 100dvh;
            width: 100%;
        }

        html,
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #2D4C7A;
            background: linear-gradient(330deg,rgba(45, 76, 122, 1) 0%, rgba(46, 99, 179, 1) 100%);
        }

        text {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        .node {
            fill: white;
        }

        .edgelabel {
            fill: orange;
        }

        @font-face {
            font-family: 'Segoe UI';
            src: local('Segoe UI'),
                url('segoe-ui/Segoe UI.ttf');
        }
    </style>

<body>
    <svg></svg>
    <script>
        // Load data:
        let data = Data['Aspirin Induced Asthma']
        // Getters for node & edge properties:
        let getNodeID = (node) => node.label;
        let getNodeLabel = (node) => node.label;
        let getEdgeType = (edge) => {return(1)};
        let getEdgeLabel = (edge) => {
            if ('label' in edge) {
                return(edge.label)
            }
            else {
                return;
            }
        };

        // page setup and dimensions:
        let svg = d3.select(document.querySelector('svg'));
        const width = document.body.getBoundingClientRect().width;
        const height = window.innerHeight;
        
        // color scheme for edges:
        const types = new Set(data.edges.map(getEdgeType));
        const color = d3.scaleOrdinal(types, [d3.color('white'), d3.color('white').darker(types.size - 1)]);
        let getEdgeColor = (edge) => color(edge.type);

        // Torque custom force:
        let torqueCustomForce = (alpha) => {        // Force that tries to rotate edges to point down
            data.edges.forEach(edge => {
                dx = edge.target.x - edge.source.x;
                dy = edge.target.y - edge.source.y;
                theta = Math.atan2(dx, dy);         // Get the angle from the vertical (the order is flipped)
                edge.target.vx += -Math.sin(theta) * alpha * dy * 0.05
                edge.target.vy += Math.sin(theta) * alpha * dx * 0.05
            });
        }

        // Build the force graph:
        const simulation = d3.forceSimulation(data.nodes)
            .force('link', d3.forceLink()           // Force keeping connected nodes together
                .id(d => d.id)                      // Tell which nodes to use
                .links(data.edges)                  // Tell which edges to use
                .strength(0.1))
            .force('charge', d3.forceManyBody()     // Force for repulsion between nodes
                .strength(-300))
            .force('center', d3.forceCenter(width / 2, height / 2)) // Positional force
            .force('torque', torqueCustomForce)
            .on('tick', () => {                     // on every sim tick:
                d3.selectAll('.edge').attr('d', edgeShape)           // draw the edge path & position text appropriately:
                d3.selectAll('.edgelabel').attr('transform', d => `translate(${(d.source.x + d.target.x) / 2}, ${(d.source.y + d.target.y) / 2})`);
                d3.selectAll('.node').attr('transform', d => `translate(${d.x}, ${d.y})`);
            });

        // Custom fade animation timing:
        const fadeEase = d3.transition()
            .duration(750)
            .ease(d3.easeLinear);

        // Arrowhead setup:
        const arrowheadSize = 6;
        svg.append('defs').selectAll('marker')
            .data(types)
            .join('marker')
            .attr('id', d => `arrow-${d}`)          // setup multiple-different arrow types if needed
            .attr('viewBox', '0 -5 10 10')
            .attr('refX', 0)                        // offset from the line end at which to draw the triangle
            .attr('refY', 0)                        // offset from the line end (perpendicular), like above
            .attr('markerWidth', arrowheadSize)     // arrowhead size
            .attr('markerHeight', arrowheadSize)    // arrowhead size
            .attr('orient', 'auto')                 // auto-rotate to face appropriately
            .append('path')
            .attr('fill', color)                    // color automatically
            .attr('d', 'M0,-5L10,0L0,5')            // triangle path to follow

        // Method for calculating arrow positions and path:
        const arrowheadToNodeOffset = 30;
        let edgeShape = (d) => {
                // Project the vector of the edge down to arrowheadToNodeOffset px:
                theta = Math.atan2(d.target.y - d.source.y, d.target.x - d.source.x)
                dx = arrowheadToNodeOffset * Math.cos(theta);
                dy = arrowheadToNodeOffset * Math.sin(theta);
                // Now, [dx, dy] is our offset vector v.
                // Move v away from the source for the tail, and move -v away from the target for the head.
                // Wrap it up into a path:
                return (`M${d.source.x + dx},${d.source.y + dy} L${d.target.x - dx},${d.target.y - dy}`)
            }

        // Build links:
        const linkContainer = svg.append('g')
            .attr('class', 'edge-container')

        function updateEdges(data) {
            // shallow copy data to protect from mutation:
            const data_copy = [...data];
            //simulation.links(data_copy);
            const edges = d3.select('.edge-container').selectAll('path')
                .data(data_copy).join(
                    enter => enter.append('path')
                                .attr('stroke', getEdgeColor)               // color appropriately
                                .attr('marker-end', d => `url("#arrow-${getEdgeType(d)}")`)
                                .attr('class', 'edge')
                                .style('opacity', 0)
                                .transition().style('opacity', 1),
                    update => update,
                    exit => exit.transition().style('opacity', 0).remove()
                )
                
        }
        updateEdges(data.edges);

        const labelContainer = svg.append('g')
            .attr('class', 'edgelabel-container')
            
        function updateEdgeLabels(data) {
            const data_filtered = data.filter(getEdgeLabel);
            const labels = d3.select('.edgelabel-container').selectAll('text')
                .data(data_filtered).join(
                    enter => enter.append('text')
                                .text(getEdgeLabel)
                                .attr('class', 'edgelabel')
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .style('opacity', 0)
                                .transition().style('opacity', 1),
                    update => update,
                    exit => exit.style('opacity', 1).transition().style('opacity', 0).remove()
                )
        }
        updateEdgeLabels(data.edges);

        // Build nodes:
        const nodeContainer = svg.append('g')
            .attr('class', 'node-container')
        
        function updateNodes(data) {
            const data_copy = [...data];
            simulation.nodes(data_copy);
            const nodes = d3.select('.node-container').selectAll('text')
                .data(data_copy).join(
                    enter => enter.append('text')
                                .text(getNodeLabel)
                                .attr('class', 'node')
                                .attr('text-anchor', 'middle')
                                .attr('dominant-baseline', 'middle')
                                .style('opacity', 0)
                                .transition().style('opacity', 1),
                    update => update,
                    exit => exit.style('opacity', 1).transition().style('opacity', 0).remove()
                )
                
        }
        updateNodes(data.nodes);

        // Interaction logic:
        let dragstarted = (event) => {              // Raise simulation temp so nodes move on drag
            if (!event.active) simulation.alphaTarget(0.3).restart();
            event.subject.fx = event.subject.x;
            event.subject.fy = event.subject.y;
        }

        let dragged = (event) => {                     // Apply a force to nodes on drag
            event.subject.fx = event.x;
            event.subject.fy = event.y;
        }

        let dragended = (event) => {
            if (!event.active) simulation.alphaTarget(0);
            event.subject.fx = null;
            event.subject.fy = null;
        }

        // Setup node drag behavior
        d3.selectAll('.node').call(d3.drag().on('start', dragstarted).on('drag', dragged).on('end', dragended))

    </script>
</body>

</html>